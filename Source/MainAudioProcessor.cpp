//
//  AudioProcessor.cpp
//  Juce Demo
//
//  Created by Aaron Leese on 5/8/11.
//  Copyright 2011 __MyCompanyName__. All rights reserved.
//

#include "MainAudioProcessor.h"

/*
 ==============================================================================
 
 This file was auto-generated by the Jucer!
 
 It contains the basic startup code for a Juce application.
 
 ==============================================================================
 */


#include <stdio.h>
#include <string.h>
#ifndef _WIN32
#include <libgen.h>
#include <dirent.h>
#endif
#include <stdlib.h>
#include <stdexcept>
#include <vector>
#include "Codegen.h"

using namespace std;

//==============================================================================
MainAudioProcessor::MainAudioProcessor()
{
    
    sampleBuffer = 0;
    
    myAudioPlayerLeft = new AudioPlayer();
    myAudioPlayerRight = new AudioPlayer();
    
    
    myAudioPlayerLeft->bpm = 120;
    myAudioPlayerRight->bpm = 120;
     
    
}

MainAudioProcessor::~MainAudioProcessor()
{
    
    delete myAudioPlayerLeft;
    delete myAudioPlayerRight;
    
}

//==============================================================================
int MainAudioProcessor::getNumParameters()
{
    return 0;
}

float MainAudioProcessor::getParameter (int index)
{
    return 0;
}

void MainAudioProcessor::setParameter (int index, float newValue)
{
     
}

const String MainAudioProcessor::getParameterName (int index)
{
    
}

const String MainAudioProcessor::getParameterText (int index)
{
    return String::empty;
}

//==============================================================================

void MainAudioProcessor::prepareToPlay (double sampleRate, int /*samplesPerBlock*/)
{

    
    // Codegen(const float* pcm, uint numSamples, int start_offset, bool low_rank);
    
    
 //   myAudioPlayerLeft->prepareToPlay(sampleRate, 512);
   // myAudioPlayerRight->prepareToPlay(sampleRate, 512);
    
    
    // open a file to a juce AudioSampleBuffer
    
    // get the pointer to the PCM float data ...
    
    
    // get numSamples
    
    // offset ?
    
    //File fileToLoad("/Users/aaronleese/Desktop/160.wav");
     
    
    /* OK, now do the code generation. Single call, takes pcm buffer (must be floats @ 22050Hz, mono), number of samples, and offset if given
     offset simply hints the FP where in the file you are taking these samples from. in this sample we take it as a CL parameter
     of course, in real code you can choose the offset programatically
     */
    

    // Print the query JSON direct to stdout.
    // NOTE: you should be escaping the filename string, the API may fail if you give it malformed JSON
    // DBG("test " + String(pCodegen->getVersion()) + " " + String(pCodegen->getCodeString().c_str()) );
    
    
    
    
    
    // Get Matts XML object ....
    
    // http://beatport1.heroku.com/beatport/most_popular/5
    // http://beatport1.heroku.com/beatport/beats/1851054
    
    
    //XmlElement* test =  http://beatport1.heroku.com/beatport/beats/1851054
    
    
    /*
    URL bpmUrl("http://beatport1.heroku.com/beatport/beats/1851054");	
    
    InputStream* stream = bpmUrl.createInputStream (true);
    
    if (stream != 0)
    {
        String data = stream->readEntireStreamAsString();
        XmlDocument* test = new XmlDocument(data);
    }
    */
    
    //  test->setInputSource (stream);    
        
    //  XmlDocument (const File &file)
    
}

void MainAudioProcessor::releaseResources()
{ 
    
}

void MainAudioProcessor::reset()
{
    
}

void MainAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    
    buffer.clear();
     
    
    float bpmShift1 = targetBpm/myAudioPlayerLeft->bpm;
    float bpmShift2 = targetBpm/myAudioPlayerRight->bpm;
    
    // now tweak slightly to get the individual beats to line up ...
    // find the numSamples * actual play rate .....
    float effectiveSamplesL = myAudioPlayerLeft->getSamplesToNextBeat()/bpmShift1; // ... 1000*slow
    float effectiveSamplesR = myAudioPlayerRight->getSamplesToNextBeat()/bpmShift2; // ... say 1000*faster
    
    if (effectiveSamplesL != 0 && effectiveSamplesL != 0) 
    {
        
        float speedRatio = effectiveSamplesR/effectiveSamplesL;
        if (speedRatio > .9 && speedRatio < 1.1)
        {
            DBG("adjusted " + String(speedRatio));
            myAudioPlayerRight->timeStretch->setValue(bpmShift2*(speedRatio));
        }
        
    }
    
    myAudioPlayerLeft->processBlock(buffer, midiMessages);
    myAudioPlayerRight->processBlock(buffer, midiMessages);
     
    
}

//==============================================================================
AudioProcessorEditor* MainAudioProcessor::createEditor()
{
    return 0;
}

//==============================================================================
void MainAudioProcessor::getStateInformation (MemoryBlock& destData)
{
           
}

void MainAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    
}

const String MainAudioProcessor::getInputChannelName (const int channelIndex) const
{
    return String (channelIndex + 1);
}

const String MainAudioProcessor::getOutputChannelName (const int channelIndex) const
{
    return String (channelIndex + 1);
}

bool MainAudioProcessor::isInputChannelStereoPair (int /*index*/) const
{
    return true;
}

bool MainAudioProcessor::isOutputChannelStereoPair (int /*index*/) const
{
    return true;
}

bool MainAudioProcessor::acceptsMidi() const
{ 
    return false; 
}

bool MainAudioProcessor::producesMidi() const
{
    return false;
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new MainAudioProcessor();
}
